formatting:

  user variables and functions are written in camel case while the ebitengine is generally pretty inconsisten.

Character naming conventions:

  specific sprites & enemy stats will be more exact perhapse even "verbose" such as; axeZombie whereas an array of it might be less descriptive like 'zombies'.

directional logic:

  in the case of where a model is facing or the direction of movement needs to be tracked, a direction of movement will declare a rune variable using wasd to exspress direction. for model direction, assets face right, so by default, declare xFacingRight as a bool and set to true.

location & relativeity:

  the window size initializes using the screenHeight & screenWidth variables in the var section of the main.go file. determining locations to draw images should prioritize using these two variable as apart of they're formula.

functions:

  functions should avoid calling on other functions unless it would aim to alleviate;

    function size, functions should avoid or aim for 50 lines maximum.

    verboseness of main file code.

  recursion should be avoided.

if & switch statements:

  if you the reader see several if statement that you think you could optimize by changing into a switch statement, dont. repetitive if statements are necesary for movement whereas a switch statement simple cannot be used for omni-directional movement.

file paths:

  relative only.

subtractive design:
  
  -limit your initial charecter classes.

  -try to base mechanics as heavily around one centreal mechanic as heavily as possible
    genre descoping; taking an element from one, larger genre & and focus in on it to make more scope resistent features that still maintain the same appeal

uniqueness from the start:

  always start a run with something unique like a different sword, buff, or level challenge/modifier

dungeon generation:

  The size of a dungeon is 12 * 12
    12 * 12 == 144
    (12 * 12) / 2 == 72
    (12 * 12) / 4 == 36
    etc...
  this is a good size to build the codebase on, allowing room for implementation of newer features in the future without major overhauls of the codebase. 
  it also ensures that we wont suffer from scope creep.

  during floor initialization stage at update function in main.go
    call initFloor() in for loop for range randint(minimum, maximum room count for current floor).
